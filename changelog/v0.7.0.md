# v0.7.0

Simplified tool surface — auto-connect replaces manual workflow, live reachability probes.

## Why

The MCP workflow forced the LLM to call `connect` before any remote tool and `disconnect` after, adding two round-trips per interaction. Since servers are always registered via the CLI (`ssh-hub add`), the `connect` tool's connection-string feature went unused — the LLM only references servers by name. Auto-connecting from config on first tool use makes both tools unnecessary. Separately, `list_servers` only showed static metadata with no way to know if a server was actually reachable before attempting a connection.

## Changes

### Auto-connect

- **`with_connection()` auto-connects from config** — when a tool references a server not in the pool, the handler looks it up in `ServerRegistry`, builds `ConnectionParams` via `params_from_config()`, and connects transparently. The LLM goes straight from `list_servers` to `remote_bash` with zero setup.

```rust
// Before: LLM had to call connect first
// Step 1: connect("staging")
// Step 2: remote_bash("staging", "ls")
// Step 3: disconnect("staging")

// After: just use the tool
// Step 1: remote_bash("staging", "ls")  ← auto-connects from config
```

- **Single config lock for auto-connect + error path** — one `config.read()` handles both the `ServerEntry` lookup and the "not found" error message (listing configured server names). No second lock acquisition needed.

### Tool surface reduction

- **Removed `connect` and `disconnect` tools** — 6 files deleted (`src/tools/connect/`, `src/tools/disconnect/`). The tool count drops from 10 to 8, reducing LLM decision overhead. Error messages guide users to `ssh-hub add` instead of the removed `connect` tool.

### Reachability probing

- **`list_servers` includes live TCP probes** — each server gets a `reachability` field with `reachable: bool` and `latency_ms: Option<u64>`. The LLM can check server availability before attempting commands.

```rust
async fn probe_reachability(host: &str, port: u16) -> ReachabilityInfo {
    let addr = format!("{}:{}", host, port);
    let start = Instant::now();
    match timeout(PROBE_TIMEOUT, TcpStream::connect(&addr)).await {
        Ok(Ok(_)) => ReachabilityInfo {
            reachable: true,
            latency_ms: Some(start.elapsed().as_millis() as u64),
        },
        _ => ReachabilityInfo { reachable: false, latency_ms: None },
    }
}
```

- **Concurrent probing via `join_all`** — all servers probed in parallel with a 3-second timeout. Total latency bounded by the slowest server, not the sum. Config read lock dropped before launching async probes to avoid holding it across I/O.
