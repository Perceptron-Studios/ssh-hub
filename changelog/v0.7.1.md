# v0.7.1

Reduced memory footprint and fixed dead connections after OS suspend/resume.

## Why

Each Claude Code session spawns a dedicated ssh-hub process. With multiple sessions open, the idle memory adds up. Profiling showed the multi-threaded tokio runtime was spawning 14 OS threads (12 CPU cores + main + signal) for an MCP server that talks to a single client over stdio — pure waste. The release binary was also unoptimized at 8.3 MB, all memory-mapped at startup.

Separately, after laptop suspend/resume, SSH connections die silently (TCP drops without FIN/RST). The old code couldn't detect this: `is_closed()` only checks russh protocol state, `channel_open_session()` hangs for ~2 minutes on the dead TCP, and the stale connection stays in the pool across retries.

## Changes

### Single-threaded runtime

- **Switched to `current_thread` tokio runtime** — the biggest win. An MCP server processes requests from one Claude Code client over stdio; there's no benefit to spreading async tasks across 12 worker threads. All SSH I/O remains fully concurrent (async polling on one thread), and `spawn_blocking` still uses its own thread pool for CPU-bound work (`build_tar_gz`, `load_secret_key`, tar extraction).

```rust
// Before: 14 threads (12 workers + main + signal handler)
#[tokio::main]
async fn main() -> Result<()> {

// After: 2 threads (main + tokio-runtime)
#[tokio::main(flavor = "current_thread")]
async fn main() -> Result<()> {
```

### Tokio feature trimming

- **Replaced `features = ["full"]` with specific features** — only `rt`, `macros`, `fs`, `net`, `time`, `sync`, `io-util`, `io-std`. Drops unused `process`, `signal`, `parking_lot` from our dependency declaration. Dependencies (russh, rmcp) still pull in what they need transitively.

### Release profile optimization

- **Added `[profile.release]` with LTO, stripping, and size optimization** — `lto = true`, `strip = true`, `codegen-units = 1`, `opt-level = "z"`. Shrinks the binary from 8.3 MB to 2.8 MB, reducing memory-mapped pages at startup.

### Benchmarks

| Metric | Before | After | Change |
|--------|--------|-------|--------|
| RSS (idle) | 10.8 MB | 7.3 MB | -32% |
| Threads | 14 | 2 | -86% |
| Binary size | 8.3 MB | 2.8 MB | -66% |

### Dead connection recovery

- **SSH keepalive enabled** — `keepalive_interval = 30s`, `keepalive_max = 3`. russh sends `keepalive@openssh.com` probes; after 3 missed responses (~90-120s) the session auto-closes and `pool.get()` removes it on next access. Matches standard OpenSSH behavior.

- **Channel open timeout** — `channel_open_session()` wrapped with a 10-second timeout. Dead connections now fail fast instead of hanging for ~2 minutes on the OS TCP timeout. On timeout, the connection is marked dead via an `AtomicBool` flag so `is_closed()` returns `true` immediately without needing the async mutex.

```rust
// Before: hangs ~2 min on dead connection
let channel = session.channel_open_session().await?;

// After: fails in 10s, marks connection dead
let channel = if let Ok(result) = tokio::time::timeout(
    Duration::from_secs(10),
    async { session.channel_open_session().await },
).await {
    result?
} else {
    self.mark_closed();
    return Err(anyhow!("Timed out opening SSH channel"));
};
```

- **Post-execution pool cleanup** — `with_connection()` checks `is_closed()` after every tool execution. If the connection died during the operation, it's removed from the pool immediately so the next tool call triggers auto-reconnect instead of hitting the same dead connection.
