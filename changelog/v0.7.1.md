# v0.7.1

Reduced per-instance memory footprint and binary size.

## Why

Each Claude Code session spawns a dedicated ssh-hub process. With multiple sessions open, the idle memory adds up. Profiling showed the multi-threaded tokio runtime was spawning 14 OS threads (12 CPU cores + main + signal) for an MCP server that talks to a single client over stdio — pure waste. The release binary was also unoptimized at 8.3 MB, all memory-mapped at startup.

## Changes

### Single-threaded runtime

- **Switched to `current_thread` tokio runtime** — the biggest win. An MCP server processes requests from one Claude Code client over stdio; there's no benefit to spreading async tasks across 12 worker threads. All SSH I/O remains fully concurrent (async polling on one thread), and `spawn_blocking` still uses its own thread pool for CPU-bound work (`build_tar_gz`, `load_secret_key`, tar extraction).

```rust
// Before: 14 threads (12 workers + main + signal handler)
#[tokio::main]
async fn main() -> Result<()> {

// After: 2 threads (main + tokio-runtime)
#[tokio::main(flavor = "current_thread")]
async fn main() -> Result<()> {
```

### Tokio feature trimming

- **Replaced `features = ["full"]` with specific features** — only `rt`, `macros`, `fs`, `net`, `time`, `sync`, `io-util`, `io-std`. Drops unused `process`, `signal`, `parking_lot` from our dependency declaration. Dependencies (russh, rmcp) still pull in what they need transitively.

### Release profile optimization

- **Added `[profile.release]` with LTO, stripping, and size optimization** — `lto = true`, `strip = true`, `codegen-units = 1`, `opt-level = "z"`. Shrinks the binary from 8.3 MB to 2.8 MB, reducing memory-mapped pages at startup.

### Benchmarks

| Metric | Before | After | Change |
|--------|--------|-------|--------|
| RSS (idle) | 10.8 MB | 7.3 MB | -32% |
| Threads | 14 | 2 | -86% |
| Binary size | 8.3 MB | 2.8 MB | -66% |
